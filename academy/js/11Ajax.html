<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Ajax</title>
</head>
<body>
<h1>Ajax</h1>
<p>ajax 통신 결과 <span id="msg"></span></p>
<div><button type="button" id="saybtn">인사말하기</button></div>
<script>
    let saybtn = document.getElementById('saybtn');
    saybtn.addEventListener('click', sayHello);
    function sayHello(){
        // 1. XMLhttpRequest 객체 초기화
        // 2. 서버에 비동기 요청 보냄
        // 3. 서버에서 응답이 오면 처리함
        let msg = document.getElementById('msg');

        // 1.
        let req = new XMLHttpRequest();

        // 3. 서버의 응답에 따라 처리할 절차를 콜백함수로 정의함
        // readystatechange : 서버에서의 응답여부 확인 이벤트 속성
        // readystate : 서버응답 속성
        // 0 : 초기화되지 않음
        // 1 : 서버와 연결성공
        // 2 : 서버가 요청 수락
        // 3 : 서버가 요청 처리중
        // 4 : 서버가 요청 처리 완료 & 곧 응답예정
        // status : HTTP 상태코드 - 요청 성공 여부 확인
        // 200 : 처리완료, 응답 잘 받음
        // 404 : 처리실패, 요청데이터가 존재하지 않음
        // 500 : 처리실패, 서버상 코드의 오류
        // responseText - 서버가 보내준 응답을 텍스트형식으로 받음

        req.onreadystatechange = function(){
            if (req.readyState == 4) { // 서버가 보낼 응답수취 여부
                if(req.status == 200){ // 처리 성공 여부
                    msg.innerHTML = req.responseText;
                } else {
                    msg.innerHTML = req.status;
                }
            } else {
                msg.innerHTML = req.readyState;
            }
        };
        // 2. 비동기방식 요청을 생성한 후 서버로 보냄
        // open(요청방식, url, 비동기여부)
        req.open('get', 'hello.txt', true)
        req.send();
    }
</script>

<h2>주소검색</h2>
<div>
    <select id="sido">
        <option>--시도--</option>
        <option>서울특별시</option>
        <option>경기도</option>
        <option>인천광역시</option>
        <option>부산광역시</option>
    </select>
    <select id="gugun">
        <option>--시/군/구--</option>
    </select>
    <select id="dong">
        <option>--읍/면/동--</option>
    </select>
</div>
<p id="addr"></p>

<script>
   // 비동기방식으로 가져올 데이터의 url 정의
    let url1 = 'http://localhost:8080/zipcode/sido.jsp'
    let url2 = 'http://localhost:8080/zipcode/gugun.jsp'
    let url3 = 'http://localhost:8080/zipcode/dong.jsp'


   //변수선언
    let sido = document.getElementById('sido');
    let gugun = document.getElementById('gugun');
    let dong = document.getElementById('dong');

    sido.addEventListener('change', makegu);

    function makegu(){
        //현재 선택한 시도의 index값을 알아냄
        let sidx = sido.selectedIndex;

        //이미 등록된 목록은 제거
        while(gugun.lastChild){//구군목록에 option 태그가 있는가?
            gugun.removeChild(gugun.lastChild);
        }

        //선택한 시도에 대한 구군목록을 배열에서 가져와서
        //구군 select 에 목록으로 추가함
        //<select><option>강남구</option></select>
        for(let gg of sgg[sidx]){
            let opt = document.createElement('option');
            let txt = document.createTextNode(gg);
            opt.appendChild(txt);
            gugun.appendChild(opt);
        }
    }
</script>
</body>
</html>
<!--
Ajax
asynchronous Javascript and XML
HTTP 프로토콜을 이용해서 비동기방식으로 데이터를 주고 받는 기법을 의미
HTTP 프로토콜은 기본적으로 동기방식의 데이터 교환만을 지원했는데
1993년 MS의 Microsoft.XMLHTTP라는 컴퍼넌트 덕택으로
비동기 처리기술이 활성화됨
2000년 12월, FF가 XMLHttpRequest라는 이름으로 지원
그 이후 2004년 4월, CR이 구글맵을 통해 Ajax기술 지원
-->
<!--
동기 vs 비동기 처리
동기 : 모든 작업은 개별 작업의 처리시간에 맞춰 실행되는 방식
    -> FIFO : 먼저 요청한 작업이 처리됨,
              처리시간이 길어지면 나머지 작업들은 하염없이 기다려야 함
       설계가 간단하고 직관적
       결과가 나올때까지 아무것도 못하고 계속 대기해야 함
       ex) 명절 기차표 예매, 은행 송금

비동기 : 모든 작업은 개별 작업의 처리시간과 상관없이 다발적으로 실행되는 방식
    -> LIFO : 먼저 요청한 작업이 먼저 끝난다고 보장하지 않음
              처리시간이 길어질 것 같으면 다른 작업을 우선적으로 실행할 수 있음
       설계가 복잡, 결과가 주어질때까지 시간이 걸리더라도
       그 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용
       ex) 마트 물건 계산
-—>

<!-
우편번호 테이블에서 데이터를 읽어오기 위한 JSP 환경 구축순서
1. JDK 설치 - amazon correto JDK 8
    JAVA_HOME 환경변수 설정
2. tomcat.apache.org에서 Tomcat 8.5.61 다운로드
 WAS : web application server
 윈도우 : 64bit window zip
 c:/Java에 압축해제
3. 기본페이지 띄우기
    bin 아래 startup.bat 실행
    브라우져에서 127.0.0.1:8080 입력 -> welcome 페이지 확인
4. 개발용 페이지 띄우기
    webapps/ROOT 디렉토리에 zipcode폴더 생성후 관련 jsp파일 복사
    브라우저에서 127.0.0.1:8080/zipcode/jsp 파일명


-->